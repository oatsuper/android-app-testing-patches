
project frameworks/base/
diff --git a/api/current.txt b/api/current.txt
index 92969f6..5b7a806 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -22857,6 +22857,7 @@ package android.view {
     method public void dispatchWindowVisibilityChanged(int);
     method public void draw(android.graphics.Canvas);
     method protected void drawableStateChanged();
+    method protected void dumpClass(android.view.ViewDebug.DumpControl);
     method public android.view.View findFocus();
     method public final android.view.View findViewById(int);
     method public final android.view.View findViewWithTag(java.lang.Object);
@@ -23401,6 +23402,16 @@ package android.view {
   public static abstract class ViewDebug.CapturedViewProperty implements java.lang.annotation.Annotation {
   }
 
+  public static class ViewDebug.DumpControl {
+    ctor public ViewDebug.DumpControl(android.view.ViewDebug.DumpControl);
+    method public void finish();
+    method public int getLevel();
+    method public void indent();
+    method public void setLevel(int);
+    method public void writeEntry(java.lang.String, java.lang.Object);
+    method public void writeViewLikeName(java.lang.Object);
+  }
+
   public static abstract class ViewDebug.ExportedProperty implements java.lang.annotation.Annotation {
   }
 
@@ -27216,6 +27227,7 @@ package android.widget {
     ctor public TableRow.LayoutParams(int);
     ctor public TableRow.LayoutParams(android.view.ViewGroup.LayoutParams);
     ctor public TableRow.LayoutParams(android.view.ViewGroup.MarginLayoutParams);
+    method protected void dumpClass(android.view.ViewDebug.DumpControl);
     field public int column;
     field public int span;
   }
diff --git a/core/java/android/view/View.java b/core/java/android/view/View.java
index 61b13d5..40cb0e1 100644
--- a/core/java/android/view/View.java
+++ b/core/java/android/view/View.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.view;
 
 import android.content.ClipData;
@@ -13418,6 +13432,82 @@ public class View implements Drawable.Callback, Drawable.Callback2, KeyEvent.Cal
         }
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp)
+    {
+        dp.writeEntry("getHeight()", getHeight());
+        dp.writeEntry("getWidth()", getWidth());
+        dp.writeEntry("getVisibility()", visibleMap(getVisibility()));
+        dp.writeEntry("hasFocus()", hasFocus());
+        dp.writeEntry("isEnabled()", isEnabled());
+        dp.writeEntry("isFocusable()", isFocusable());
+        dp.writeEntry("isFocused()", isFocused());
+        dp.writeEntry("isSelected()", isSelected());
+        dp.writeResolvedId("mID", mID);
+        dp.writeEntry("mMeasuredHeight", mMeasuredHeight);
+        dp.writeEntry("mMeasuredWidth", mMeasuredWidth);
+        dp.writeEntry("mLeft", mLeft);
+        dp.writeEntry("mTop", mTop);
+        dp.writeEntry("mScrollY", mScrollY);
+    }
+
+    String visibleMap(int visibility) {
+        if(visibility == View.VISIBLE) return "VISIBLE";
+        if(visibility == View.INVISIBLE) return "INVISIBLE";
+        if(visibility == View.GONE) return "GONE";
+        return "unknownVisibility(" + visibility + ")";
+    }
+
+    class FlagMapping {
+        int mask;
+        int equals;
+        String name;
+        String value;
+        boolean outputIf;
+
+        public void init(int mask, int equals, String name, String value, boolean outputIf) {
+            this.mask = mask;
+            this.equals = equals;
+            this.name = name;
+            this.value = value;
+            this.outputIf = outputIf;
+        }
+        public FlagMapping(int mask, int equals, String name, String value, boolean outputIf) {
+            init(mask, equals, name, value, outputIf);
+        }
+        public FlagMapping(int mask, int equals, String name, String value) {
+            init(mask, equals, name, value, true);
+        }
+    }
+
+
+    FlagMapping privateFlagsDecoder[] = new FlagMapping[]{
+        new FlagMapping(FORCE_LAYOUT, FORCE_LAYOUT, "mPrivateFlags_FORCE_LAYOUT", "0x1000"),
+        new FlagMapping(LAYOUT_REQUIRED, LAYOUT_REQUIRED, "mPrivateFlags_LAYOUT_REQUIRED", "0x2000"),
+        new FlagMapping(DRAWING_CACHE_VALID, DRAWING_CACHE_VALID,
+                "mPrivateFlags_DRAWING_CACHE_INVALID", "0x0", false),
+        new FlagMapping(DRAWN, DRAWN, "mPrivateFlags_DRAWN", "0x20", true),
+        new FlagMapping(DRAWN, DRAWN, "mPrivateFlags_NOT_DRAWN", "0x0", false),
+        new FlagMapping(DIRTY_MASK, DIRTY_OPAQUE, "mPrivateFlags_DIRTY_OPAQUE", "0x400000"),
+        new FlagMapping(DIRTY_MASK, DIRTY, "mPrivateFlags_DIRTY", "0x200000")
+    };
+
+    void flagMapping(ViewDebug.DumpControl dp) {
+        for(int i = 0; i < privateFlagsDecoder.length; i++) {
+            FlagMapping flagDecoder = privateFlagsDecoder[i];
+            int maskedResult = mPrivateFlags & flagDecoder.mask;
+            if(maskedResult == flagDecoder.equals) {
+                if(flagDecoder.outputIf) {
+                    dp.writeEntry(flagDecoder.name, flagDecoder.value);
+                }
+            } else {
+                if(!flagDecoder.outputIf) {
+                    dp.writeEntry(flagDecoder.name, flagDecoder.value);
+                }
+            }
+        }
+    }
+
+    
     /**
      * Inflate a view from an XML resource.  This convenience method wraps the {@link
      * LayoutInflater} class, which provides a full range of options for view inflation.
diff --git a/core/java/android/view/ViewDebug.java b/core/java/android/view/ViewDebug.java
index 65e72c9..ed1d227 100644
--- a/core/java/android/view/ViewDebug.java
+++ b/core/java/android/view/ViewDebug.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.view;
 
@@ -27,6 +42,10 @@ import android.os.Looper;
 import android.os.Message;
 import android.os.ParcelFileDescriptor;
 import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.content.IClipboard;
+import android.content.ClipData;
+import android.text.TextUtils;
 import android.os.SystemClock;
 import android.util.DisplayMetrics;
 import android.util.Log;
@@ -347,6 +366,7 @@ public class ViewDebug {
 
     private static final String REMOTE_COMMAND_CAPTURE = "CAPTURE";
     private static final String REMOTE_COMMAND_DUMP = "DUMP";
+    private static final String REMOTE_COMMAND_DUMP_TESTING = "DUMPQ";
     private static final String REMOTE_COMMAND_INVALIDATE = "INVALIDATE";
     private static final String REMOTE_COMMAND_REQUEST_LAYOUT = "REQUEST_LAYOUT";
     private static final String REMOTE_PROFILE = "PROFILE";
@@ -925,10 +945,13 @@ public class ViewDebug {
             try {
                 out.close();
             } catch (IOException e) {
-                Log.e("View", "Could not dump view hierarchy");
+                Log.e("ViewDebug", "Could not dump view hierarchy2");
             }
+        } else {
+            Log.w("ViewDebug", "view not instance of ViewGroup: " + view.getClass().getName());
         }
 
+
         sHierarhcyRoot = null;
     }
 
@@ -940,6 +963,8 @@ public class ViewDebug {
 
         if (REMOTE_COMMAND_DUMP.equalsIgnoreCase(command)) {
             dump(view, clientStream);
+        } else if (REMOTE_COMMAND_DUMP_TESTING.equalsIgnoreCase(command)) {
+            dumpForTesting(view, clientStream);
         } else if (REMOTE_COMMAND_CAPTURE_LAYERS.equalsIgnoreCase(command)) {
             captureLayers(view, new DataOutputStream(clientStream));
         } else {
@@ -1294,11 +1319,44 @@ public class ViewDebug {
                 ViewGroup group = (ViewGroup) view;
                 dumpViewHierarchyWithProperties(group.getContext(), group, out, 0);
             }
+        } catch (Exception e) {
+            android.util.Log.w("View", "Problem dumping the view:", e);
+        } finally {
             out.write("DONE.");
             out.newLine();
+            if (out != null) {
+                out.close();
+            }
+        }
+    }
+
+    /**
+     * Similiar to ViewDebug.dump(), but instead of
+     * decoding annotations to dump the GUI
+     * objects (ViewDebug.ExportProperty for example),
+     * dumpForTesting calls code in the GUI objects
+     * to dump themselves.    Apps
+     * whose GUI is based on OpenGL (instead of
+     * View) can add code to dump their GUI during testing.
+     *
+     * @param root - the object being dumped
+     * @param clientStream - the stream (on the socket) to the client
+     */
+    private static void dumpForTesting(View root, OutputStream clientStream) throws IOException {
+        BufferedWriter out = null;
+        try {
+            out = new BufferedWriter(new OutputStreamWriter(clientStream, "utf-8"), 32 * 1024);
+            View view = root.getRootView();
+            if (view instanceof ViewGroup) {
+                ViewGroup group = (ViewGroup) view;
+                DumpControl dumpInfo = new DumpControl(group.getContext(), out);
+                dumpInfo.dumpViewHierarchyWithProperties(group, 0);
+            }
         } catch (Exception e) {
-            android.util.Log.w("View", "Problem dumping the view:", e);
+            android.util.Log.w("View", "[t]Problem dumping the view:", e);
         } finally {
+            out.write("DONE.");
+            out.newLine();
             if (out != null) {
                 out.close();
             }
@@ -1330,6 +1388,59 @@ public class ViewDebug {
         return view.getClass().getName().equals(className) && view.hashCode() == hashCode;
     }
 
+    private static IClipboard mClipboard = null;
+
+    private static void dumpClipboard(Context context, BufferedWriter out) {
+        try {
+            CharSequence t = null;
+            // see frameworks/base/core/java android.content.ClipboardManager
+            mClipboard = IClipboard.Stub.asInterface(ServiceManager
+                    .getService("clipboard"));
+            if (mClipboard != null) {
+                if (mClipboard.hasPrimaryClip()) {
+                    ClipData clip = mClipboard.getPrimaryClip(context
+                            .getPackageName());
+                    if (clip != null && clip.getItemCount() > 0) {
+                        t = clip.getItemAt(0).coerceToText(context);
+                    } else {
+                        Log.w("ViewDebug", "clipboard: clip exists, is empty");
+                    }
+                } else {
+                    Log.w("ViewDebug", "clipboard: no primary clip");
+                }
+            } else {
+                Log.w("ViewDebug", "clipboard: no clipboard");
+            }
+            if (t == null)
+                return;
+            // IClipboard clip =
+            // IClipboard.Stub.asInterface(ServiceManager.getService("clipboard"));
+            // if(clip != null) {
+            // CharSequence t = clip.getClipboardText();
+            int last = t.length();
+            if (last <= 0)
+                return;
+            final int MAX_CHARS_TO_REPORT = 500;
+            if (last >= MAX_CHARS_TO_REPORT)
+                last = MAX_CHARS_TO_REPORT - 1;
+            char[] temp = new char[MAX_CHARS_TO_REPORT];
+            TextUtils.getChars(t, 0, last, temp, 0);
+            int len = 0;
+            for (; len < temp.length; len++) {
+                if (temp[len] == '\0')
+                    break;
+            }
+            if (len == 0)
+                return;
+            writeEntry(out, "", "clipboardText", "()",
+                    String.copyValueOf(temp, 0, len));
+        } catch (IOException e) {
+            Log.e("ViewDebug", "dumpClipboard failed", e);
+        } catch (Exception e) {
+            Log.e("ViewDebug", "e dumpClipboard failed", e);
+        }
+    }
+
     private static void dumpViewHierarchyWithProperties(Context context, ViewGroup group,
             BufferedWriter out, int level) {
         if (!dumpViewWithProperties(context, group, out, level)) {
@@ -1339,12 +1450,55 @@ public class ViewDebug {
         final int count = group.getChildCount();
         for (int i = 0; i < count; i++) {
             final View view = group.getChildAt(i);
+            if(view == null) {
+                logInconsistency(i, count, group);
+            }
             if (view instanceof ViewGroup) {
                 dumpViewHierarchyWithProperties(context, (ViewGroup) view, out, level + 1);
             } else {
-                dumpViewWithProperties(context, view, out, level + 1);
+                if( ! dumpViewWithProperties(context, view, out, level + 1)) {
+                    Log.w("ViewDebug", "  - child " + (i + 1) + "/" + count +
+                          " of " + group.getClass().getName());
+                }
+            }
+        }
+    }
+
+    // If 'About phone -> Status' window is visible and 'Up time' is
+    // scrolled into view, for a brief period every second, when the
+    // time on 'Up time' changes, the children of the Status window will
+    // be inconsistent. See test above prior to call of logInconsistency().
+    //
+    private static View logInconsistency(int i, int count, ViewGroup group) {
+        View view;
+        Log.w("ViewDebug", "child " + (i + 1) + "/" + count + " is null: "
+                + theChildren(group));
+        try {
+            Thread.sleep(100);
+        } catch (Exception e) {
+            ;
+        }
+        view = group.getChildAt(i);
+        // I want to know which child had the problem!
+        Log.w("ViewDebug", "child 100 ms later: "
+                + ((view == null) ? "null" : view.getClass().getName() + '@'
+                        + Integer.toHexString(view.hashCode())) + ": "
+                + theChildren(group));
+        return view;
+    }
+
+    static String theChildren(ViewGroup group) {
+        final int count = group.getChildCount();
+        String list = "[" + count + "] ";
+        for (int i = 0; i < count; i++) {
+            View view = group.getChildAt(i);
+            if (view != null) {
+                list += Integer.toHexString(view.hashCode()) + " ";
+            } else {
+                list += "null ";
             }
         }
+        return list;
     }
 
     private static boolean dumpViewWithProperties(Context context, View view,
@@ -1358,11 +1512,23 @@ public class ViewDebug {
             out.write('@');
             out.write(Integer.toHexString(view.hashCode()));
             out.write(' ');
-            dumpViewProperties(context, view, out);
+            dumpViewLocation(view, out);
+            // do not dump any properties *after* calling
+            // dumpViewProperties.
+            dumpViewProperties(context, view, out, "");
+            if(level == 0) {
+                dumpOrientation(view, out);
+                dumpClipboard(context, out);
+            }
             out.newLine();
         } catch (IOException e) {
             Log.w("View", "Error while dumping hierarchy tree");
             return false;
+        } catch (Exception e2) {
+            // e.g., when HV views 'about phone' > 'Status' (changing 'Up time')
+            Log.w("ViewDebug", "Exception (" + e2.getMessage()
+                    + ") while dumping hierarchy tree");
+            return false;
         }
         return true;
     }
@@ -1438,12 +1604,6 @@ public class ViewDebug {
     }
 
     private static void dumpViewProperties(Context context, Object view,
-            BufferedWriter out) throws IOException {
-
-        dumpViewProperties(context, view, out, "");
-    }
-
-    private static void dumpViewProperties(Context context, Object view,
             BufferedWriter out, String prefix) throws IOException {
 
         Class<?> klass = view.getClass();
@@ -1455,6 +1615,409 @@ public class ViewDebug {
         } while (klass != Object.class);
     }
 
+    /**
+     * Holds the parameters and provides routines for dumping a GUI object
+     * hierarchy to an automated testing client.
+     */
+    public static class DumpControl {
+        private BufferedWriter out;
+        private Context context;
+        private int viewLevel;
+        private int level;
+
+        /**
+         * Holds a pointer to a dumpClass() method
+         */
+        private class MethodHolder {
+            Method dumpClass = null;
+        }
+
+        private static HashMap<Class<?>, MethodHolder> previouslyDumped;
+
+        @SuppressWarnings("unused")
+        private DumpControl() {
+            ;
+        }
+
+        private DumpControl(Context context, BufferedWriter out) {
+            this.context = context;
+            this.out = out;
+        }
+
+        /**
+         * copy constructor. Creates a new DumpControl object initialized just
+         * like the original. Changes to the indent <i>level</i> (e.g.) of the
+         * new DumpControl object will not change the original.
+         *
+         * @param dp - original DumpControl object from which to copy values.
+         */
+        public DumpControl(DumpControl dp) {
+            out = dp.out;
+            context = dp.context;
+            level = dp.level;
+        }
+
+        /**
+         * write a field or method value of the current object to the output
+         * stream. The entry will look like: name=n,value, where n is an integer
+         * giving exactly the number of characters in the string representation
+         * of value.
+         *
+         * @param name
+         *            - the name of the field or method. If a method, then "()"
+         *            should be suffixed to the name: "getHeight()".
+         * @param value
+         *            - the value of the field or the return value of the method
+         *            after calling it.
+         */
+        public void writeEntry(String name, Object value) {
+            try {
+                if (out == null) {
+                    Log.w("ViewDebug", "writeEntry(" + name + "): out is null");
+                    return;
+                }
+                out.write(name);
+                out.write('=');
+                writeValue(value);
+                out.write(' ');
+            } catch (IOException ioe) {
+                Log.e("ViewDebug", "IOException writeEntry(" + name + "): "
+                        + ioe, ioe);
+                // if I/O is screwed up, let's bail.
+                throw new RuntimeException("IO Exception in writeEntryNoSuf");
+            }
+        }
+
+        /**
+         * @hide
+         */
+        public void writeResolvedId(String idName, int idValue) {
+            if (context != null) {
+                writeEntry(idName, resolveId(idValue));
+            }
+        }
+
+        private Object resolveId(int idValue) {
+            return ViewDebug.resolveId(context, idValue);
+        }
+
+        /**
+         * write a View-like name into the dump, Classname@hash, for example:
+         * com.android.internal.policy.impl.PhoneWindow$DecorView@450197d0
+         *
+         * @param viewLikeObj
+         *            - the object whose name is to be written.
+         */
+        public void writeViewLikeName(Object viewLikeObj) {
+            try {
+                out.write(viewLikeObj.getClass().getName());
+                out.write('@');
+                out.write(Integer.toHexString(viewLikeObj.hashCode()));
+                out.write(' ');
+            } catch (IOException iox) {
+                Log.e("ViewDebug", "trying to writeViewLikeName: "
+                        + viewLikeObj.getClass().getName(), iox);
+            }
+
+        }
+
+        /**
+         * Set the current indentation level, that is, how many blanks are
+         * written before the beginning of a line. Typical use:
+         *
+         * <pre>
+         * dp.setLevel(dp.getLevel() + 1);
+         * </pre>
+         *
+         * @param level
+         *            - the new indentation level.
+         */
+        public void setLevel(int level) {
+            this.level = level;
+        }
+
+        /**
+         * @return the current indentation level
+         */
+        public int getLevel() {
+            return level;
+        }
+
+        /**
+         * indent the current line to the current level.
+         */
+        public void indent() {
+            for (int i = 0; i < level; i++) {
+                try {
+                    out.write(' ');
+                } catch (IOException ioe) {
+                    Log.e("ViewDebug", "IOException [indent](" + level + "): "
+                            + ioe.getMessage(), ioe);
+                    throw new RuntimeException(
+                            "I/O Exception in DumpParams.indent()");
+                }
+            }
+        }
+
+        /**
+         * Used to terminate a line when you know for certain that a new line of
+         * data is about to be output. Only used when the View structure doesn't
+         * take care of this automatically, e.g., AllApps3D, 3D Gallery's
+         * RenderView.
+         */
+        public void finish() {
+            try {
+                out.newLine();
+            } catch (IOException ioe) {
+                Log.e("ViewDebug",
+                        "finish(): Unexpected exception: " + ioe.getMessage(),
+                        ioe);
+                throw new RuntimeException(
+                        "I/O Exception writing a newline (finish())");
+            }
+        }
+
+        private static char null4[] = { '4', ',', 'n', 'u', 'l', 'l' };
+
+        /**
+         * sends a value to the socket in the form: n,XXX where n is the number
+         * of characters in XXX. For efficiency, check for null, which occurs a
+         * fair amount. Examples are:
+         * <ul>
+         * <li>4,true -- boolean true
+         * <li>11,Hello World -- String "Hello World"
+         * <li>3,-15 -- int -15
+         * <li>4,null -- null
+         * </ul>
+         *
+         * @param value
+         *            - the value to be written
+         * @throws IOException
+         *             - if the writing does not work
+         */
+        private void writeValue(Object value) throws IOException {
+            if (value != null) {
+                String output = value.toString().replace("\n", "\\n");
+                writeInt(output.length());
+                out.write(',');
+                efficientWrite(output);
+            } else {
+                synchronized (null4) {
+                    out.write(null4);
+                }
+            }
+        }
+
+        static private char buf64[] = new char[64];
+
+        /**
+         * efficiently write text to the output stream. The efficiency comes
+         * from not allocating any extra memory to write the string.
+         *
+         * @param text
+         *            - the text to write
+         * @throws IOException
+         */
+        private void efficientWrite(String text) throws IOException {
+            final int len = text.length();
+            if (len <= 64) {
+                synchronized (buf64) {
+                    text.getChars(0, len, buf64, 0);
+                    out.write(buf64, 0, len);
+                }
+            } else {
+                out.write(text);
+            }
+        }
+
+        private char dig[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
+
+        private void writeInt(int iVal) throws IOException {
+            if (iVal >= 0 && iVal < 100) {
+                if (iVal > 9) {
+                    out.write(dig[iVal / 10]);
+                }
+                out.write(dig[iVal % 10]);
+            } else {
+                efficientWrite(String.valueOf(iVal));
+            }
+        }
+
+        /**
+         * Recursively dump the View structure rooted at <i>viewGroup</i> as
+         * lines of text. The dump represents containment by indentation. If a
+         * View object contains child View objects, the direct children are
+         * indented (one blank) from the parent. The total indentation count is
+         * the <i>level</i>.
+         *
+         * @param viewGroup
+         *            - the object to dump
+         * @param level
+         *            - the indentation level.
+         */
+        private void dumpViewHierarchyWithProperties(ViewGroup viewGroup,
+                int level) {
+            if (!dumpViewWithProperties(viewGroup, level)) {
+                return;
+            }
+
+            final int count = viewGroup.getChildCount();
+            for (int i = 0; i < count; i++) {
+                View view = viewGroup.getChildAt(i);
+                if (view == null) {
+                    logInconsistency(i, count, viewGroup);
+                }
+                if (view instanceof ViewGroup) {
+                    dumpViewHierarchyWithProperties((ViewGroup) view, level + 1);
+                } else {
+                    if (!dumpViewWithProperties(view, level + 1)) {
+                        Log.w("ViewDebug", "  - [q] child " + (i + 1) + "/"
+                                + count + " of "
+                                + viewGroup.getClass().getName());
+                    }
+                }
+            }
+        }
+
+        /**
+         * Dump one View object (one line of the dump).
+         *
+         * @param view
+         *            - the View object
+         * @param level
+         *            - the indentation level
+         * @return false if there was an exception, true if it worked.
+         */
+        private boolean dumpViewWithProperties(View view, int level) {
+            try {
+                for (int i = 0; i < level; i++) {
+                    out.write(' ');
+                }
+                viewLevel = level;
+                writeViewLikeName(view);
+                dumpViewLocation(view, out);
+                dumpViewProperties(view);
+                if (level == 0) {
+                    dumpOrientation(view, out);
+                    dumpClipboard(context, out);
+                }
+                // This newLine() terminates the dump of this View. Do not dump
+                // (i.e., tack on) any properties *after* calling
+                // dumpViewWithProperties.
+                out.newLine();
+            } catch (IOException e) {
+                Log.w("View", "[q]Error while dumping hierarchy tree", e);
+                return false;
+            } catch (Exception e2) {
+                // e.g., when HV views 'about phone' > 'Status' (changing 'Up
+                // time')
+                Log.w("ViewDebug", "[q]Exception (" + e2.getMessage()
+                        + ") while dumping hierarchy tree", e2);
+                return false;
+            }
+            return true;
+        }
+
+        private void dumpViewProperties(Object view) throws IOException {
+            Class<?> klass = view.getClass();
+            do {
+                // exportClass calls the GUI object's dumpClass method, if there
+                // is one.
+                // dumpClass is responsible for calling its super's dumpClass.
+                if (exportClass(view, klass))
+                    return;
+                klass = klass.getSuperclass();
+            } while (klass != Object.class);
+        }
+
+        /**
+         * use introspection to call the <i>view</i>'s dumpClass() method to
+         * export (i.e., dump) the <i>klass</i>'s fields and method values.
+         * Introspection to find if an object has a dumpClass() method allocates
+         * a fair amount of memory, so only do it one time, saving the result in
+         * the previouslyDumped table.
+         *
+         * @param view
+         *            - the View object
+         * @param klass
+         *            - the Java Class of the <i>view</i> object
+         * @return false if dumpClass() could not be called, true if it was
+         *         successfully called.
+         */
+        private boolean exportClass(Object view, Class<?> klass)
+                throws IOException {
+            if (previouslyDumped == null) {
+                previouslyDumped = new HashMap<Class<?>, MethodHolder>();
+            }
+            MethodHolder method = previouslyDumped.get(klass);
+            if (method == null) {
+                try {
+                    method = new MethodHolder();
+                    method.dumpClass = klass.getDeclaredMethod("dumpClass",
+                            DumpControl.class);
+                    if (method.dumpClass == null)
+                        return false;
+                    method.dumpClass.setAccessible(true); // allow us to invoke
+                                                            // this method
+                    previouslyDumped.put(klass, method);
+                } catch (NoSuchMethodException nsme) {
+                    // save a MethodHolder for this klass with .dumpClass ==
+                    // null
+                    previouslyDumped.put(klass, new MethodHolder());
+                    return false;
+                } catch (SecurityException se) {
+                    Log.w("ViewDebug",
+                            "[q]"
+                                    + klass.getName()
+                                    + ": security exception trying to getDeclaredMethod(\"dumpClass\")");
+                    return false;
+                }
+            } else if (method.dumpClass == null) {
+                // we've looked up this klass.method before, it doesn't exist
+                return false;
+            }
+
+            try {
+                this.level = viewLevel;
+                method.dumpClass.invoke(view, this);
+            } catch (Exception e) {
+                Log.w("ViewDebug", "[q]" + klass.getName() + "."
+                        + method.dumpClass.getName() + ": " + e, e);
+                throw new RuntimeException("dumpClass() error");
+            }
+            return true;
+        }
+    }
+
+    // end of DumpControl
+
+    private static void dumpOrientation(View view, BufferedWriter out) {
+        try {
+            int orientation = view.getResources().getConfiguration().orientation;
+            Log.d("ViewDebug", "orientation: " + orientation);
+            writeEntry(out, "", "orientation", "", orientation);
+        } catch (IOException iox) {
+            Log.w("ViewDebug", iox.getMessage()
+                    + ": exception in dumpOrientation()");
+        }
+    }
+
+    private static void dumpViewLocation(View view, BufferedWriter out) {
+        if ((view != null) && view.mAttachInfo != null) {
+            int screenLocation[] = new int[2];
+            ((View) view).getLocationOnScreen(screenLocation);
+            try {
+                writeEntry(out, "", "screenX", "",
+                        Integer.toString(screenLocation[0]));
+                writeEntry(out, "", "screenY", "",
+                        Integer.toString(screenLocation[1]));
+            } catch (IOException ioe) {
+                Log.w("ViewDebug", ioe.getMessage()
+                        + ": exception in dumpViewLocation()");
+            }
+        }
+    }
+
     private static void exportMethods(Context context, Object view, BufferedWriter out,
             Class<?> klass, String prefix) throws IOException {
 
diff --git a/core/java/android/view/ViewGroup.java b/core/java/android/view/ViewGroup.java
index 62b20b3..2f08e3a 100644
--- a/core/java/android/view/ViewGroup.java
+++ b/core/java/android/view/ViewGroup.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.view;
 
 import android.animation.LayoutTransition;
@@ -5222,6 +5236,28 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
         })
         public int height;
 
+        /** @hide **/
+        protected void dumpClass(ViewDebug.DumpControl dp) {
+            dp.writeEntry("height", matchOrWrap(height));
+            dp.writeEntry("width", matchOrWrap(width));
+        }
+
+        /**
+         * @hide
+         */
+        protected Object matchOrWrap(int param)
+        {
+            if(param == ViewGroup.LayoutParams.MATCH_PARENT) {
+                return "MATCH_PARENT";
+            }
+            if(param == ViewGroup.LayoutParams.WRAP_CONTENT) {
+                return "WRAP_CONTENT";
+            }
+            return param;
+        }
+
+
+
         /**
          * Used to animate layouts.
          */
diff --git a/core/java/android/webkit/WebView.java b/core/java/android/webkit/WebView.java
index fef9b02..9b137b7 100644
--- a/core/java/android/webkit/WebView.java
+++ b/core/java/android/webkit/WebView.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.webkit;
 
 import android.annotation.Widget;
@@ -74,6 +88,7 @@ import android.view.SoundEffectConstants;
 import android.view.VelocityTracker;
 import android.view.View;
 import android.view.ViewConfiguration;
+import android.view.ViewDebug;
 import android.view.ViewGroup;
 import android.view.ViewParent;
 import android.view.ViewTreeObserver;
@@ -9571,6 +9586,77 @@ public class WebView extends AbsoluteLayout
     static final int NO_LEFTEDGE = -1;
     native int nativeGetBlockLeftEdge(int x, int y, float scale);
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("browserFocusArea()", browserFocusArea());
+        dp.writeEntry("browserFocusOn()", browserFocusOn());
+        dp.writeEntry("browserFocusText()", browserFocusText());
+        dp.writeEntry("browserFocusName()", browserFocusName());
+        dp.writeEntry("browserFocusType()", browserFocusType());
+        dp.writeEntry("browserCursor()", browserCursor());
+        dp.writeEntry("browserCursorArea()", browserCursorArea());
+        dp.writeEntry("browserCursorOn()", browserCursorOn());
+        dp.writeEntry("browserCursorText()", browserCursorText());
+        dp.writeEntry("browserCursorRing()", browserCursorRing());
+        dp.writeEntry("browserCursorType()", browserCursorType());
+        super.dumpClass(dp);
+    }
+
+    private String browserFocusArea() {
+        Rect nativeBnds = nativeFocusCandidateNodeBounds();
+        Rect viewBnds = contentToViewRect( nativeBnds );
+        return String.format("l=%d,r=%d,t=%d,b=%d", viewBnds.left, viewBnds.right, viewBnds.top, viewBnds.bottom);
+    }
+
+    private boolean browserFocusOn() {
+        return nativeHasFocusNode();
+    }
+
+    private String browserFocusText() {
+        return nativeFocusCandidateText();
+    }
+
+    private String browserFocusName() {
+        return nativeFocusCandidateName();
+    }
+
+    private String browserFocusType() {
+        if( nativeFocusCandidateIsTextInput() ) return "textInput";
+        return "other";
+    }
+
+    private String browserCursor() {
+        Point position = nativeCursorPosition();
+        int x = contentToViewX( position.x );
+        int y = contentToViewY( position.y );
+        return String.format("x=%d,y=%d", x, y);
+    }
+
+    private String browserCursorArea() {
+        Rect nativeBnds = nativeCursorNodeBounds();
+        Rect viewBnds = contentToViewRect( nativeBnds );
+        return String.format("l=%d,r=%d,t=%d,b=%d", viewBnds.left, viewBnds.right, viewBnds.top, viewBnds.bottom);
+    }
+
+    private boolean browserCursorOn() {
+        return nativeHasCursorNode();
+    }
+
+    private String browserCursorText() {
+        return nativeCursorText();
+    }
+
+    private String browserCursorRing() {
+        Rect nativeBnds = nativeGetCursorRingBounds();
+        Rect viewBnds = contentToViewRect( nativeBnds );
+        return String.format("l=%d,r=%d,t=%d,b=%d", viewBnds.left, viewBnds.right, viewBnds.top, viewBnds.bottom);
+    }
+
+    private String browserCursorType() {
+        if( nativeCursorIsTextInput() ) return "textInput";
+        if( nativeCursorIsAnchor() ) return "Anchor";
+        return "other";
+    }
+
     private native void     nativeUseHardwareAccelSkia(boolean enabled);
 
     // Returns a pointer to the scrollable LayerAndroid at the given point.
diff --git a/core/java/android/widget/AbsListView.java b/core/java/android/widget/AbsListView.java
index 38bb2e1..dc87b5d 100644
--- a/core/java/android/widget/AbsListView.java
+++ b/core/java/android/widget/AbsListView.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.widget;
 
 import com.android.internal.R;
@@ -6058,6 +6072,16 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("getSelectedView()", getSelectedView());
+        dp.writeEntry("isFastScrollEnabled()", isFastScrollEnabled());
+        dp.writeEntry("isScrollingCacheEnabled()", isScrollingCacheEnabled());
+        dp.writeEntry("isSmoothScrollbarEnabled()", isSmoothScrollbarEnabled());
+        dp.writeEntry("isStackFromBottom()", isStackFromBottom());
+        dp.writeEntry("isTextFilterEnabled()", isTextFilterEnabled());
+        super.dumpClass(dp);
+    }
+
     static View retrieveFromScrap(ArrayList<View> scrapViews, int position) {
         int size = scrapViews.size();
         if (size > 0) {
diff --git a/core/java/android/widget/AdapterView.java b/core/java/android/widget/AdapterView.java
index 40df168..0da0a4a 100644
--- a/core/java/android/widget/AdapterView.java
+++ b/core/java/android/widget/AdapterView.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.widget;
 
 import android.content.Context;
@@ -1143,6 +1157,14 @@ public abstract class AdapterView<T extends Adapter> extends ViewGroup {
         }
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("mFirstPosition", mFirstPosition);
+        dp.writeEntry("mItemCount", mItemCount);
+        dp.writeEntry("mNextSelectedPosition", mNextSelectedPosition);
+        dp.writeEntry("mSelectedPosition", mSelectedPosition);
+        super.dumpClass(dp);
+    }
+
     /**
      * Remember enough information to restore the screen state when the data has
      * changed.
diff --git a/core/java/android/widget/CheckedTextView.java b/core/java/android/widget/CheckedTextView.java
index 0a54743..0513743 100644
--- a/core/java/android/widget/CheckedTextView.java
+++ b/core/java/android/widget/CheckedTextView.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.widget;
 
 import com.android.internal.R;
@@ -233,6 +247,11 @@ public class CheckedTextView extends TextView implements Checkable {
         }
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("isChecked()", isChecked());
+        super.dumpClass(dp);
+    }
+
     @Override
     public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
         super.onInitializeAccessibilityNodeInfo(info);
diff --git a/core/java/android/widget/CompoundButton.java b/core/java/android/widget/CompoundButton.java
index d3cdad8..1cf91d4 100644
--- a/core/java/android/widget/CompoundButton.java
+++ b/core/java/android/widget/CompoundButton.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.widget;
 
 import com.android.internal.R;
@@ -335,6 +349,11 @@ public abstract class CompoundButton extends Button implements Checkable {
         return ss;
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("isChecked()", isChecked());
+        super.dumpClass(dp);
+    }
+
     @Override
     public void onRestoreInstanceState(Parcelable state) {
         SavedState ss = (SavedState) state;
diff --git a/core/java/android/widget/ImageView.java b/core/java/android/widget/ImageView.java
index b24dd69..609269a 100644
--- a/core/java/android/widget/ImageView.java
+++ b/core/java/android/widget/ImageView.java
@@ -364,6 +364,16 @@ public class ImageView extends View {
             invalidate();
         }
     }
+    
+    protected void dumpClass(ViewDebug.DumpControl pdc) {
+    	super.dumpClass(pdc);
+    	String smUri = "null";
+    	if(mUri != null) {
+    		smUri = mUri.toString();
+    	}
+    	pdc.writeEntry("mUri", smUri);
+    	pdc.writeEntry("mResource", mResource);
+    }
 
     /**
      * Sets a Bitmap as the content of this ImageView.
diff --git a/core/java/android/widget/ProgressBar.java b/core/java/android/widget/ProgressBar.java
index df88fec..e4aabbf 100644
--- a/core/java/android/widget/ProgressBar.java
+++ b/core/java/android/widget/ProgressBar.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.widget;
 
 import com.android.internal.R;
@@ -1097,6 +1111,13 @@ public class ProgressBar extends View {
         setSecondaryProgress(ss.secondaryProgress);
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("getProgress()", getProgress());
+        dp.writeEntry("getSecondaryProgress()", getSecondaryProgress());
+        dp.writeEntry("getMax()", getMax());
+        super.dumpClass(dp);
+    }
+
     @Override
     protected void onAttachedToWindow() {
         super.onAttachedToWindow();
diff --git a/core/java/android/widget/TableRow.java b/core/java/android/widget/TableRow.java
index 3fd4631..a010592 100644
--- a/core/java/android/widget/TableRow.java
+++ b/core/java/android/widget/TableRow.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.widget;
 
 import android.content.Context;
@@ -502,8 +516,16 @@ public class TableRow extends LinearLayout {
                 height = WRAP_CONTENT;
             }
         }
+        
+        protected void dumpClass(ViewDebug.DumpControl dp) {
+            dp.writeEntry("layout_column", column);
+            dp.writeEntry("layout_span", span);
+            super.dumpClass(dp);
+        }
     }
 
+
+
     // special transparent hierarchy change listener
     private class ChildrenTracker implements OnHierarchyChangeListener {
         private OnHierarchyChangeListener listener;
diff --git a/core/java/android/widget/TextView.java b/core/java/android/widget/TextView.java
index 0a2365e..5e2cc7f 100644
--- a/core/java/android/widget/TextView.java
+++ b/core/java/android/widget/TextView.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package android.widget;
 
 import android.R;
@@ -11419,6 +11433,13 @@ public class TextView extends View implements ViewTreeObserver.OnPreDrawListener
         }
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("mText", mText);
+        dp.writeEntry("getSelectionStart()", getSelectionStart());
+        dp.writeEntry("getSelectionEnd()", getSelectionEnd());
+        super.dumpClass(dp);
+    }
+
     @ViewDebug.ExportedProperty(category = "text")
     private CharSequence            mText;
     private CharSequence            mTransformed;
diff --git a/services/java/com/android/server/wm/ViewServer.java b/services/java/com/android/server/wm/ViewServer.java
index a763e2c..640fbf3 100644
--- a/services/java/com/android/server/wm/ViewServer.java
+++ b/services/java/com/android/server/wm/ViewServer.java
@@ -13,10 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.android.server.wm;
 
 
+import android.os.ParcelFileDescriptor;
 import android.util.Slog;
 
 import java.net.ServerSocket;
@@ -179,6 +194,45 @@ class ViewServer implements Runnable {
         }
     }
 
+    private boolean windowCommandWithDone(Socket client, String command, String parameters)
+    {
+        boolean result;
+        long cmdStartMillis = System.currentTimeMillis();
+
+        result = mWindowManager.viewServerWindowCommand(client, command, parameters);
+
+        long cmdDuration = System.currentTimeMillis() - cmdStartMillis;
+        if(client.getChannel() != null && client.getChannel().isOpen()) {
+           try {
+               // If viewServerWindowCommand() worked then this code
+               // doesn't accomplish anything because the client has already
+               // seen a DONE and isn't listening.  If something went wrong
+               // (e.g., the window Id in the command is not valid), this
+               // code will write the only DONE line the client will receive.
+               ParcelFileDescriptor out = ParcelFileDescriptor.fromSocket(client);
+               OutputStream clientStream = new ParcelFileDescriptor.AutoCloseOutputStream(out);
+               BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(clientStream), 64);
+
+               bw.write("DONE.");
+               bw.newLine();
+               bw.write("workaround. ");
+               if(result) {
+                   bw.write('t');
+               } else {
+                   bw.write('f');
+               }
+               bw.newLine();
+               bw.flush();
+               bw.close();
+           } catch (Exception ex) {
+               Slog.e(LOG_TAG, "failed writing cleanup output stream", ex);
+           }
+        }
+        
+        Slog.d(LOG_TAG, command + "-done " + Long.toString(cmdDuration));
+        return result;
+    }
+
     private static boolean writeValue(Socket client, String value) {
         boolean result;
         BufferedWriter out = null;
@@ -246,8 +300,8 @@ class ViewServer implements Runnable {
                 } else if (COMMAND_WINDOW_MANAGER_AUTOLIST.equalsIgnoreCase(command)) {
                     result = windowManagerAutolistLoop();
                 } else {
-                    result = mWindowManager.viewServerWindowCommand(mClient,
-                            command, parameters);
+                    Slog.d(LOG_TAG, request);
+                    result = windowCommandWithDone(mClient, command, parameters);
                 }
 
                 if (!result) {
diff --git a/services/java/com/android/server/wm/WindowManagerService.java b/services/java/com/android/server/wm/WindowManagerService.java
index a199a7e..225aa64 100644
--- a/services/java/com/android/server/wm/WindowManagerService.java
+++ b/services/java/com/android/server/wm/WindowManagerService.java
@@ -13,7 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.android.server.wm;
 
 import static android.view.WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW;
@@ -5651,6 +5665,7 @@ public class WindowManagerService extends IWindowManager.Stub
 
             final WindowState window = findWindow(hashCode);
             if (window == null) {
+            	Slog.w("WindowManagerService", "window for " + hashCode + " (" + code + ") is null");
                 return false;
             }
 

