
project frameworks/base/
diff --git a/core/java/android/view/GestureDetector.java b/core/java/android/view/GestureDetector.java
index c1e1049..f65e938 100644
--- a/core/java/android/view/GestureDetector.java
+++ b/core/java/android/view/GestureDetector.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.view;
 
@@ -20,6 +35,7 @@ import android.content.Context;
 import android.os.Build;
 import android.os.Handler;
 import android.os.Message;
+import android.os.SystemClock;
 
 /**
  * Detects various gestures and events using the supplied {@link MotionEvent}s.
@@ -256,7 +272,7 @@ public class GestureDetector {
 
         @Override
         public void handleMessage(Message msg) {
-            switch (msg.what) {
+           switch (msg.what) {
             case SHOW_PRESS:
                 mListener.onShowPress(mCurrentDownEvent);
                 break;
@@ -454,7 +470,7 @@ public class GestureDetector {
 
         boolean handled = false;
 
-        switch (action & MotionEvent.ACTION_MASK) {
+       switch (action & MotionEvent.ACTION_MASK) {
         case MotionEvent.ACTION_POINTER_DOWN:
             if (mIgnoreMultitouch) {
                 // Multitouch event - abort.
@@ -503,12 +519,17 @@ public class GestureDetector {
             mStillDown = true;
             mInLongPress = false;
             
+            long downTime = mCurrentDownEvent.getDownTime();
             if (mIsLongpressEnabled) {
+            	if(downTime == -1) {
+            		// event came from Monkey
+            		downTime = SystemClock.uptimeMillis();
+            	}
                 mHandler.removeMessages(LONG_PRESS);
-                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime()
+                mHandler.sendEmptyMessageAtTime(LONG_PRESS, downTime// mCurrentDownEvent.getDownTime()
                         + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
             }
-            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
+            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, downTime /*mCurrentDownEvent.getDownTime()*/ + TAP_TIMEOUT);
             handled |= mListener.onDown(ev);
             break;
 
diff --git a/core/java/android/view/View.java b/core/java/android/view/View.java
index 1766345..4b4f788 100644
--- a/core/java/android/view/View.java
+++ b/core/java/android/view/View.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.view;
 
@@ -8791,7 +8806,80 @@ public class View implements Drawable.Callback, KeyEvent.Callback, Accessibility
         }
         return newSet;
     }
+    
+    protected void dumpClass(ViewDebug.DumpControl dp)
+    {   	
+        dp.writeEntry("getHeight()", getHeight());
+        dp.writeEntry("getWidth()", getWidth());
+        dp.writeEntry("getVisibility()", visibleMap(getVisibility()));
+        dp.writeEntry("hasFocus()", hasFocus());
+        dp.writeEntry("isEnabled()", isEnabled());
+        dp.writeEntry("isFocusable()", isFocusable());
+        dp.writeEntry("isFocused()", isFocused());
+        dp.writeEntry("isSelected()", isSelected());
+        dp.writeResolvedId("mID", mID);
+        dp.writeEntry("mMeasuredHeight", mMeasuredHeight);
+        dp.writeEntry("mMeasuredWidth", mMeasuredWidth);
+        dp.writeEntry("mLeft", mLeft);
+        dp.writeEntry("mTop", mTop);
+        dp.writeEntry("mScrollY", mScrollY);
+    }
+
+    String visibleMap(int visibility) {
+        if(visibility == View.VISIBLE) return "VISIBLE";
+        if(visibility == View.INVISIBLE) return "INVISIBLE";
+        if(visibility == View.GONE) return "GONE";
+        return "unknownVisibility(" + visibility + ")";
+    }
+
+    class FlagMapping {
+        int mask;
+        int equals;
+        String name;
+        String value;
+        boolean outputIf;
+
+        public void init(int mask, int equals, String name, String value, boolean outputIf) {
+            this.mask = mask;
+            this.equals = equals;
+            this.name = name;
+            this.value = value;
+            this.outputIf = outputIf;
+        }
+        public FlagMapping(int mask, int equals, String name, String value, boolean outputIf) {
+            init(mask, equals, name, value, outputIf);
+        }
+        public FlagMapping(int mask, int equals, String name, String value) {
+            init(mask, equals, name, value, true);
+        }
+    }
+
+    FlagMapping privateFlagsDecoder[] = new FlagMapping[]{
+        new FlagMapping(FORCE_LAYOUT, FORCE_LAYOUT, "mPrivateFlags_FORCE_LAYOUT", "0x1000"),
+        new FlagMapping(LAYOUT_REQUIRED, LAYOUT_REQUIRED, "mPrivateFlags_LAYOUT_REQUIRED", "0x2000"),
+        new FlagMapping(DRAWING_CACHE_VALID, DRAWING_CACHE_VALID,
+                "mPrivateFlags_DRAWING_CACHE_INVALID", "0x0", false),
+        new FlagMapping(DRAWN, DRAWN, "mPrivateFlags_DRAWN", "0x20", true),
+        new FlagMapping(DRAWN, DRAWN, "mPrivateFlags_NOT_DRAWN", "0x0", false),
+        new FlagMapping(DIRTY_MASK, DIRTY_OPAQUE, "mPrivateFlags_DIRTY_OPAQUE", "0x400000"),
+        new FlagMapping(DIRTY_MASK, DIRTY, "mPrivateFlags_DIRTY", "0x200000")
+    };
 
+    void flagMapping(ViewDebug.DumpControl dp) {
+        for(int i = 0; i < privateFlagsDecoder.length; i++) {
+            FlagMapping flagDecoder = privateFlagsDecoder[i];
+            int maskedResult = mPrivateFlags & flagDecoder.mask;
+            if(maskedResult == flagDecoder.equals) {
+                if(flagDecoder.outputIf) {
+                    dp.writeEntry(flagDecoder.name, flagDecoder.value);
+                }
+            } else {
+                if(!flagDecoder.outputIf) {
+                    dp.writeEntry(flagDecoder.name, flagDecoder.value);
+                }
+            }
+        }
+    }
     /**
      * Inflate a view from an XML resource.  This convenience method wraps the {@link
      * LayoutInflater} class, which provides a full range of options for view inflation.
diff --git a/core/java/android/view/ViewDebug.java b/core/java/android/view/ViewDebug.java
index 7b6991f..a60a610 100644
--- a/core/java/android/view/ViewDebug.java
+++ b/core/java/android/view/ViewDebug.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.view;
 
@@ -27,6 +42,9 @@ import android.graphics.Rect;
 import android.os.Environment;
 import android.os.Debug;
 import android.os.RemoteException;
+import android.os.ServiceManager;
+import android.text.IClipboard;
+import android.text.TextUtils;
 
 import java.io.ByteArrayOutputStream;
 import java.io.File;
@@ -159,6 +177,15 @@ public class ViewDebug {
     }
 
     /**
+     * The "DUMP" command has two implementations.  This
+     * flag determines which is used.  <b>false</b> => (the
+     * original implementation) uses the annotations 
+     * defined in this class. <b>true</b> => calls a routine
+     * in the object to dump itself.  
+     */
+    private static boolean lessSlowDump = true;
+
+    /**
      * This annotation can be used to mark fields and methods to be dumped by
      * the view server. Only non-void methods with no arguments can be annotated
      * by this annotation.
@@ -353,6 +380,7 @@ public class ViewDebug {
 
     private static final String REMOTE_COMMAND_CAPTURE = "CAPTURE";
     private static final String REMOTE_COMMAND_DUMP = "DUMP";
+    private static final String REMOTE_COMMAND_DUMP_TESTING = "DUMPQ";
     private static final String REMOTE_COMMAND_INVALIDATE = "INVALIDATE";
     private static final String REMOTE_COMMAND_REQUEST_LAYOUT = "REQUEST_LAYOUT";
     private static final String REMOTE_PROFILE = "PROFILE";
@@ -706,8 +734,10 @@ public class ViewDebug {
             try {
                 out.close();
             } catch (IOException e) {
-                Log.e("View", "Could not dump view hierarchy");
+                Log.e("ViewDebug", "Could not dump view hierarchy2");
             }
+        } else {
+            Log.w("ViewDebug", "view not instance of ViewGroup: " + view.getClass().getName());
         }
 
         sHierarhcyRoot = null;
@@ -860,7 +890,9 @@ public class ViewDebug {
         view = view.getRootView();
 
         if (REMOTE_COMMAND_DUMP.equalsIgnoreCase(command)) {
-            dump(view, clientStream);
+       		dump(view, clientStream);
+        } else if (REMOTE_COMMAND_DUMP_TESTING.equalsIgnoreCase(command)) {
+      		dumpForTesting(view, clientStream);
         } else if (REMOTE_COMMAND_CAPTURE_LAYERS.equalsIgnoreCase(command)) {
             captureLayers(view, new DataOutputStream(clientStream));
         } else {
@@ -1203,11 +1235,44 @@ public class ViewDebug {
                 ViewGroup group = (ViewGroup) view;
                 dumpViewHierarchyWithProperties(group.getContext(), group, out, 0);
             }
+        } catch (Exception e) {
+            android.util.Log.w("View", "Problem dumping the view:", e);
+        } finally {
             out.write("DONE.");
             out.newLine();
+            if (out != null) {
+                out.close();
+            }
+        }
+    }
+
+    /**
+     * Similiar to ViewDebug.dump(), but instead of
+     * decoding annotations to dump the GUI 
+     * objects (ViewDebug.ExportProperty for example),
+     * dumpForTesting calls code in the GUI objects
+     * to dump themselves.    Apps 
+     * whose GUI is based on OpenGL (instead of
+     * View) can add code to dump their GUI during testing.
+     * 
+     * @param root - the object being dumped
+     * @param clientStream - the stream (on the socket) to the client
+     */
+    private static void dumpForTesting(View root, OutputStream clientStream) throws IOException {
+        BufferedWriter out = null;
+        try {
+            out = new BufferedWriter(new OutputStreamWriter(clientStream, "utf-8"), 32 * 1024);
+            View view = root.getRootView();
+            if (view instanceof ViewGroup) {
+                ViewGroup group = (ViewGroup) view;
+                DumpControl dumpInfo = new DumpControl(group.getContext(), out);
+                dumpInfo.dumpViewHierarchyWithProperties(group, 0);
+            }
         } catch (Exception e) {
-            android.util.Log.w("View", "Problem dumping the view:", e);
+            android.util.Log.w("View", "[q]Problem dumping the view:", e);
         } finally {
+            out.write("DONE.");
+            out.newLine();
             if (out != null) {
                 out.close();
             }
@@ -1238,6 +1303,30 @@ public class ViewDebug {
     private static boolean isRequestedView(View view, String className, int hashCode) {
         return view.getClass().getName().equals(className) && view.hashCode() == hashCode;
     }
+    
+    private static void dumpClipboard(BufferedWriter out) {
+        try {
+            IClipboard clip = IClipboard.Stub.asInterface(ServiceManager.getService("clipboard"));
+            if (clip != null) {
+                CharSequence t = clip.getClipboardText();
+                int last = t.length();
+                if(last <= 0) return;
+                final int MAX_CHARS_TO_REPORT = 500;
+                if(last >= MAX_CHARS_TO_REPORT) last = MAX_CHARS_TO_REPORT - 1;
+                char[] temp = new char[MAX_CHARS_TO_REPORT];
+                TextUtils.getChars(t, 0, last, temp, 0);
+                int len = 0;
+                for(; len<temp.length;len++) {if(temp[len] == '\0') break;}
+                if(len == 0) return;
+                writeEntry(out, "", "clipboardText", "()", String.copyValueOf(temp,0,len));
+            }
+        } catch  (IOException e) {
+            Log.e("ViewDebug", "dumpClipboard failed", e);
+        } catch (Exception e) {
+            Log.e("ViewDebug", "e dumpClipboard failed", e);
+        }
+    }
+
 
     private static void dumpViewHierarchyWithProperties(Context context, ViewGroup group,
             BufferedWriter out, int level) {
@@ -1248,13 +1337,55 @@ public class ViewDebug {
         final int count = group.getChildCount();
         for (int i = 0; i < count; i++) {
             final View view = group.getChildAt(i);
+            if(view == null) {
+            	logInconsistency(i, count, group);
+            }
             if (view instanceof ViewGroup) {
                 dumpViewHierarchyWithProperties(context, (ViewGroup) view, out, level + 1);
             } else {
-                dumpViewWithProperties(context, view, out, level + 1);
+                if(!dumpViewWithProperties(context, view, out, level + 1)) {
+                    Log.w("ViewDebug", "  - child " + (i + 1) + "/" + count + " of " + group.getClass().getName());
+                }
             }
         }
     }
+    
+    // If 'About phone -> Status' window is visible and 'Up time' is
+    // scrolled into view, for a brief period every second, when the
+    // time on 'Up time' changes, the children of the Status window will
+    // be inconsistent.  See test above prior to call of logInconsistency().
+    //
+    private static View logInconsistency(int i, int count, ViewGroup group) {
+        View view;
+        Log.w("ViewDebug", "child " + (i + 1) + "/" + count + " is null: " + theChildren(group));
+        try {
+                Thread.sleep(100);
+        } catch (Exception e) {
+                ;
+        }
+        view = group.getChildAt(i);
+        // I want to know which child had the problem!
+        Log.w("ViewDebug", "child 100 ms later: " + ((view == null) ? "null" :
+                        view.getClass().getName() + '@' + Integer.toHexString(view.hashCode())) +
+                        ": " + theChildren(group));
+        return view;
+    }
+    
+    static String theChildren(ViewGroup group)
+    {
+        final int count = group.getChildCount();
+        String list = "[" + count +"] ";
+        for (int i = 0; i < count; i++) {
+            View view = group.getChildAt(i);
+            if(view != null) {
+                list += Integer.toHexString(view.hashCode()) + " ";
+            } else {
+                list += "null ";
+            }
+        }
+        return list;
+    }
+
 
     private static boolean dumpViewWithProperties(Context context, View view,
             BufferedWriter out, int level) {
@@ -1267,11 +1398,22 @@ public class ViewDebug {
             out.write('@');
             out.write(Integer.toHexString(view.hashCode()));
             out.write(' ');
-            dumpViewProperties(context, view, out);
+            dumpViewLocation(view, out);
+            // do not dump any properties *after* calling
+            // dumpViewProperties.
+            dumpViewProperties(context, view, out, "");
+            if(level == 0) {
+            	dumpOrientation(view, out);
+            	dumpClipboard(out);
+            }
             out.newLine();
         } catch (IOException e) {
             Log.w("View", "Error while dumping hierarchy tree");
             return false;
+        } catch (Exception e2) {
+            // e.g., when HV views 'about phone' > 'Status' (changing 'Up time')
+            Log.w("ViewDebug", "Exception (" + e2.getMessage() +") while dumping hierarchy tree");
+            return false;
         }
         return true;
     }
@@ -1349,12 +1491,6 @@ public class ViewDebug {
     }
 
     private static void dumpViewProperties(Context context, Object view,
-            BufferedWriter out) throws IOException {
-
-        dumpViewProperties(context, view, out, "");
-    }
-
-    private static void dumpViewProperties(Context context, Object view,
             BufferedWriter out, String prefix) throws IOException {
 
         Class<?> klass = view.getClass();
@@ -1366,6 +1502,333 @@ public class ViewDebug {
         } while (klass != Object.class);
     }
 
+
+    /**
+     * Holds the parameters and provides routines for dumping a GUI object hierarchy to an automated testing client.
+     */
+    public static class DumpControl {
+        private BufferedWriter out;
+        private Context context;
+        private int viewLevel;
+        private int level;
+
+        /**
+         * Holds a pointer to a dumpClass() method
+         */
+        private class MethodHolder {
+            Method dumpClass = null;
+        }
+        private static HashMap<Class<?>, MethodHolder> previouslyDumped;
+        
+        @SuppressWarnings("unused")
+		private DumpControl() {
+        	;
+        }
+        
+        private DumpControl(Context context,  BufferedWriter out) {
+        	this.context = context;
+        	this.out = out;
+        }
+
+        /**
+         * copy constructor.  Creates a new DumpControl object initialized
+         * just like the original.  Changes to the indent <i>level</i> (e.g.)
+         * of the new DumpControl object will not change the original.
+         * 
+         * @param dp - original DumpControl object from which to copy values.
+         */
+        public DumpControl(DumpControl dp) {
+        	out = dp.out;
+        	context = dp.context;
+        	level = dp.level;
+        }
+
+        /**
+         * write a field or method value of the current object to the output stream.
+         * The entry will look like:  name=n,value, where n is an integer giving
+         * exactly the number of characters in the string representation of value.
+         * @param name - the name of the field or method.  If a method, then "()"
+         *      should be suffixed to the name: "getHeight()".
+         * @param value - the value of the field or the return value of the method after calling it.
+         */
+        public void writeEntry(String name, Object value) {
+            try {
+            	if(out == null) {
+            		Log.w("ViewDebug", "writeEntry(" + name + "): out is null");
+            		return;
+            	}
+                out.write(name);
+                out.write('=');
+                writeValue(value);
+                out.write(' ');
+            } catch (IOException ioe) {
+                Log.e("ViewDebug", "IOException writeEntry(" + name + "): " + ioe, ioe);
+                // if I/O is screwed up, let's bail.
+                throw new RuntimeException("IO Exception in writeEntryNoSuf");
+            }
+        }
+        
+        /**
+         * @hide
+         */
+        public void writeResolvedId(String idName, int idValue) {
+            if(context != null) {
+                writeEntry(idName, resolveId(idValue));
+            }
+        }
+
+        private Object resolveId(int idValue) {
+        	return ViewDebug.resolveId(context, idValue);
+        }
+
+        /**
+         * write a View-like name into the dump, Classname@hash, for example:
+         * com.android.internal.policy.impl.PhoneWindow$DecorView@450197d0
+         * @param viewLikeObj - the object whose name is to be written.
+         */
+        public void writeViewLikeName(Object viewLikeObj) {
+        	try {
+	            out.write(viewLikeObj.getClass().getName());
+	            out.write('@');
+	            out.write(Integer.toHexString(viewLikeObj.hashCode()));
+	            out.write(' ');
+        	} catch (IOException iox) {
+        		Log.e("ViewDebug", "trying to writeViewLikeName: " + viewLikeObj.getClass().getName(), iox);
+        	}
+        	
+        }
+
+        /**
+         * Set the current indentation level, that is, how many blanks are written before the
+         * beginning of a line.  Typical use:
+         * <pre>
+         *     dp.setLevel(dp.getLevel() + 1);
+         * </pre>
+         * @param level - the new indentation level.
+         */
+        public void setLevel(int level) {
+        	this.level = level;
+        }
+        /**
+         * @return the current indentation level
+         */
+        public int getLevel() {
+        	return level;
+        }
+
+        /**
+         * indent the current line to the current level.
+         */
+        public void indent() {
+            for(int i = 0; i < level; i++) {
+            	try {
+            		out.write(' ');
+            	} catch (IOException ioe) {
+            		Log.e("ViewDebug", "IOException [indent](" + level +"): " + ioe.getMessage(), ioe);
+            		throw new RuntimeException("I/O Exception in DumpParams.indent()");
+            	}
+            }        	
+        }
+
+        /**
+         * Used to terminate a line when you know for certain that
+         * a new line of data is about to be output.  Only used
+         * when the View structure doesn't take care of this
+         * automatically, e.g., AllApps3D, 3D Gallery's RenderView.
+         */
+        public void finish() {
+        	try {
+        		out.newLine();
+        	} catch (IOException ioe) {
+        		Log.e("ViewDebug", "finish(): Unexpected exception: " + ioe.getMessage(), ioe);
+        		throw new RuntimeException("I/O Exception writing a newline (finish())");
+        	}
+        }
+
+        private static char null4[] = {'4', ',', 'n', 'u', 'l', 'l'};
+        
+        /**
+         * sends a value to the socket in the form: n,XXX where n is
+         * the number of characters in XXX.  For efficiency, check for
+         * null, which occurs a fair amount.  Examples are:
+         * <ul>
+         * <li>4,true -- boolean true
+         * <li>11,Hello World -- String "Hello World"
+         * <li>3,-15 -- int -15
+         * <li>4,null  -- null
+         * </ul
+         * @param value - the value to be written
+         * @throws IOException - if the writing does not work
+         */
+         private void writeValue(Object value) throws IOException {
+            if (value != null) {
+                String output = value.toString().replace("\n", "\\n");
+                writeInt(output.length());
+                out.write(',');
+                efficientWrite(output);
+            } else {
+            	synchronized(null4) {
+            		out.write(null4);
+            	}
+            }
+        }
+
+        static private char buf64[] = new char[64];
+
+        /**
+         * efficiently write text to the output stream.  The efficiency
+         * comes from not allocating any extra memory to write the
+         * string.
+         * @param text - the text to write
+         * @throws IOException
+         */
+        private void efficientWrite(String text) throws IOException {
+            final int len = text.length();
+            if(len <= 64) {
+            	synchronized(buf64) {
+            		text.getChars(0, len, buf64, 0);
+            		out.write(buf64, 0, len);
+            	}
+            } else {
+                out.write(text);
+            }
+        }
+
+        private char dig[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
+
+        private void writeInt(int iVal) throws IOException {
+            if(iVal >= 0 && iVal < 100) {
+                if(iVal > 9) {
+                    out.write(dig[iVal / 10]);
+                }
+                out.write(dig[iVal % 10]);
+            } else {
+                efficientWrite(String.valueOf(iVal));
+            }
+        }
+
+
+        /**
+         * Recursively dump the View structure rooted at <i>viewGroup</i> as lines
+         * of text.  The dump
+         * represents containment by indentation.  If a View object contains child
+         * View objects, the direct children are indented (one blank) from the parent.
+         * The total indentation count is the <i>level</i>.
+         * @param viewGroup - the object to dump
+         * @param level - the indentation level.
+         */
+        private void dumpViewHierarchyWithProperties(ViewGroup viewGroup, int level) {
+            if (!dumpViewWithProperties(viewGroup, level)) {
+                return;
+            }
+
+            final int count = viewGroup.getChildCount();
+            for (int i = 0; i < count; i++) {
+                View view = viewGroup.getChildAt(i);
+                if(view == null) {
+                	logInconsistency(i, count, viewGroup);
+                }
+                if (view instanceof ViewGroup) {
+                    dumpViewHierarchyWithProperties((ViewGroup)view, level + 1);
+                } else {
+                    if(!dumpViewWithProperties(view, level + 1)) {
+                        Log.w("ViewDebug", "  - [q] child " + (i + 1) + "/" + count +
+                        		" of " + viewGroup.getClass().getName());
+                    }
+                }
+            }
+        }
+
+        /**
+         * Dump one View object (one line of the dump).
+         * @param view - the View object
+         * @param level - the indentation level
+         * @return false if there was an exception, true if it worked.
+         */
+        private boolean dumpViewWithProperties(View view, int level) {
+            try {
+                for (int i = 0; i < level; i++) {
+                    out.write(' ');
+                }
+                viewLevel = level;
+                writeViewLikeName(view);
+                dumpViewLocation(view, out);
+                dumpViewProperties(view);
+                if(level == 0) {
+                	dumpOrientation(view, out);
+                	dumpClipboard(out);
+                }
+                // This newLine() terminates the dump of this View.  Do not dump
+                // (i.e., tack on) any properties *after* calling dumpViewWithProperties.
+                out.newLine();
+            } catch (IOException e) {
+                Log.w("View", "[q]Error while dumping hierarchy tree", e);
+                return false;
+            } catch (Exception e2) {
+                // e.g., when HV views 'about phone' > 'Status' (changing 'Up time')
+                Log.w("ViewDebug", "[q]Exception (" + e2.getMessage() +") while dumping hierarchy tree", e2);
+                return false;
+            }
+            return true;
+        }
+      
+        private void dumpViewProperties(Object view) throws IOException {
+            Class<?> klass = view.getClass();
+            do {
+            	// exportClass calls the GUI object's dumpClass method, if there is one.
+            	// dumpClass is responsible for calling its super's dumpClass.
+                if(exportClass(view, klass)) return;
+                klass = klass.getSuperclass();
+            } while (klass != Object.class);
+        }
+        
+        /**
+         * use introspection to call the <i>view</i>'s dumpClass() method to export
+         * (i.e., dump) the <i>klass</i>'s fields and method values.
+         * Introspection to find if an object has a dumpClass() method allocates
+         * a fair amount of memory, so only do it one time, saving the result in
+         * the previouslyDumped table.
+         * @param view - the View object
+         * @param klass - the Java Class of the <i>view</i> object
+         * @return false if dumpClass() could not be called, true if it was successfully called.
+         */
+        private boolean exportClass(Object view, Class<?> klass)	throws IOException  {
+            if(previouslyDumped == null) {
+                previouslyDumped = new HashMap<Class<?>, MethodHolder>();
+            }
+            MethodHolder method = previouslyDumped.get(klass);
+            if(method == null) {
+                try {
+                    method = new MethodHolder();
+                    method.dumpClass = klass.getDeclaredMethod("dumpClass", DumpControl.class);
+                    if(method.dumpClass == null) return false;
+                    method.dumpClass.setAccessible(true);  // allow us to invoke this method
+                    previouslyDumped.put(klass, method);
+                } catch (NoSuchMethodException nsme) {
+                	// save a MethodHolder for this klass with .dumpClass == null
+                    previouslyDumped.put(klass, new MethodHolder());
+                    return false;
+                } catch (SecurityException se) {
+                    Log.w("ViewDebug", "[q]" + klass.getName() + ": security exception trying to getDeclaredMethod(\"dumpClass\")");
+                    return false;
+                }
+            } else if(method.dumpClass == null) {
+                // we've looked up this klass.method before, it doesn't exist
+                return false;
+            }
+
+            try {
+            	this.level = viewLevel;
+                method.dumpClass.invoke(view, this);
+            } catch (Exception e) {
+                Log.w("ViewDebug", "[q]" + klass.getName() + "." + method.dumpClass.getName() + ": " + e, e);
+                throw new RuntimeException("dumpClass() error");
+            }
+            return true;
+        }
+    }
+    // end of DumpParams
+
     private static void exportMethods(Context context, Object view, BufferedWriter out,
             Class<?> klass, String prefix) throws IOException {
 
@@ -1439,6 +1902,30 @@ public class ViewDebug {
         }
     }
 
+    private static void dumpOrientation(View view, BufferedWriter out) {
+    	try {   	
+    		int orientation = view.getResources().getConfiguration().orientation;
+    		Log.d("ViewDebug", "orientation: " + orientation);
+    		writeEntry(out, "", "orientation", "", orientation);
+    	} catch (IOException iox) {
+    		Log.w("ViewDebug", iox.getMessage() + ": exception in dumpOrientation()");
+    	}
+    }
+    
+    private static void dumpViewLocation(View view, BufferedWriter out)
+    {
+        if((view != null) && view.mAttachInfo != null) {
+            int screenLocation[] = new int[2];
+            ((View)view).getLocationOnScreen(screenLocation);
+            try {
+                writeEntry(out, "", "screenX", "", Integer.toString(screenLocation[0]));
+                writeEntry(out, "", "screenY", "", Integer.toString(screenLocation[1]));
+            } catch (IOException ioe) {
+                Log.w("ViewDebug", ioe.getMessage() + ": exception in dumpViewLocation()");
+            }
+        }
+    }
+
     private static void exportFields(Context context, Object view, BufferedWriter out,
             Class<?> klass, String prefix) throws IOException {
 
@@ -1593,8 +2080,11 @@ public class ViewDebug {
             writeEntry(out, prefix, name, suffix, value);
         }
     }
-
-    static Object resolveId(Context context, int id) {
+    
+    /**
+     * @hide
+     */
+    public static Object resolveId(Context context, int id) {
         Object fieldValue;
         final Resources resources = context.getResources();
         if (id >= 0) {
@@ -1614,7 +2104,7 @@ public class ViewDebug {
         if (value != null) {
             String output = value.toString().replace("\n", "\\n");
             out.write(String.valueOf(output.length()));
-            out.write(",");
+            out.write(',');
             out.write(output);
         } else {
             out.write("4,null");
diff --git a/core/java/android/view/ViewGroup.java b/core/java/android/view/ViewGroup.java
index 2b71b4a..76efad6 100644
--- a/core/java/android/view/ViewGroup.java
+++ b/core/java/android/view/ViewGroup.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.view;
 
@@ -3522,6 +3537,27 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
             @ViewDebug.IntToString(from = WRAP_CONTENT, to = "WRAP_CONTENT")
         })
         public int height;
+        
+        protected void dumpClass(ViewDebug.DumpControl dp) {
+            dp.writeEntry("height", matchOrWrap(height));
+            dp.writeEntry("width", matchOrWrap(width));
+        }
+        
+        /**
+         * @hide
+         */
+        protected Object matchOrWrap(int param)
+        {
+            if(param == ViewGroup.LayoutParams.MATCH_PARENT) {
+                return "MATCH_PARENT";
+            }
+            if(param == ViewGroup.LayoutParams.WRAP_CONTENT) {
+                return "WRAP_CONTENT";
+            }
+            return param;
+        }
+
+
 
         /**
          * Used to animate layouts.
diff --git a/core/java/android/webkit/WebView.java b/core/java/android/webkit/WebView.java
index 1915425..8f7b5d9 100644
--- a/core/java/android/webkit/WebView.java
+++ b/core/java/android/webkit/WebView.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.webkit;
 
@@ -64,6 +79,7 @@ import android.view.SoundEffectConstants;
 import android.view.VelocityTracker;
 import android.view.View;
 import android.view.ViewConfiguration;
+import android.view.ViewDebug;
 import android.view.ViewGroup;
 import android.view.ViewTreeObserver;
 import android.view.animation.AlphaAnimation;
@@ -7949,4 +7965,75 @@ public class WebView extends AbsoluteLayout
     // return NO_LEFTEDGE means failure.
     private static final int NO_LEFTEDGE = -1;
     private native int      nativeGetBlockLeftEdge(int x, int y, float scale);
+    
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("browserFocusArea()", browserFocusArea());
+        dp.writeEntry("browserFocusOn()", browserFocusOn());
+        dp.writeEntry("browserFocusText()", browserFocusText());
+        dp.writeEntry("browserFocusName()", browserFocusName());
+        dp.writeEntry("browserFocusType()", browserFocusType());
+        dp.writeEntry("browserCursor()", browserCursor());
+        dp.writeEntry("browserCursorArea()", browserCursorArea());
+        dp.writeEntry("browserCursorOn()", browserCursorOn());
+        dp.writeEntry("browserCursorText()", browserCursorText());
+        dp.writeEntry("browserCursorRing()", browserCursorRing());
+        dp.writeEntry("browserCursorType()", browserCursorType());
+        super.dumpClass(dp);
+    }
+
+    private String browserFocusArea() {
+        Rect nativeBnds = nativeFocusCandidateNodeBounds();
+        Rect viewBnds = contentToViewRect( nativeBnds );
+        return String.format("l=%d,r=%d,t=%d,b=%d", viewBnds.left, viewBnds.right, viewBnds.top, viewBnds.bottom);
+    }
+
+    private boolean browserFocusOn() {
+        return nativeHasFocusNode();
+    }
+
+    private String browserFocusText() {
+        return nativeFocusCandidateText();
+    }
+
+    private String browserFocusName() {
+        return nativeFocusCandidateName();
+    }
+
+    private String browserFocusType() {
+        if( nativeFocusCandidateIsTextInput() ) return "textInput";
+        return "other";
+    }
+
+    private String browserCursor() {
+        Point position = nativeCursorPosition();
+        int x = contentToViewX( position.x );
+        int y = contentToViewY( position.y );
+        return String.format("x=%d,y=%d", x, y);
+    }
+
+    private String browserCursorArea() {
+        Rect nativeBnds = nativeCursorNodeBounds();
+        Rect viewBnds = contentToViewRect( nativeBnds );
+        return String.format("l=%d,r=%d,t=%d,b=%d", viewBnds.left, viewBnds.right, viewBnds.top, viewBnds.bottom);
+    }
+
+    private boolean browserCursorOn() {
+        return nativeHasCursorNode();
+    }
+
+    private String browserCursorText() {
+        return nativeCursorText();
+    }
+
+    private String browserCursorRing() {
+        Rect nativeBnds = nativeGetCursorRingBounds();
+        Rect viewBnds = contentToViewRect( nativeBnds );
+        return String.format("l=%d,r=%d,t=%d,b=%d", viewBnds.left, viewBnds.right, viewBnds.top, viewBnds.bottom);
+    }
+
+    private String browserCursorType() {
+        if( nativeCursorIsTextInput() ) return "textInput";
+        if( nativeCursorIsAnchor() ) return "Anchor";
+        return "other";
+    }
 }
diff --git a/core/java/android/widget/AbsListView.java b/core/java/android/widget/AbsListView.java
index 35ef4cb..b6e984d 100644
--- a/core/java/android/widget/AbsListView.java
+++ b/core/java/android/widget/AbsListView.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.widget;
 
@@ -4659,4 +4674,14 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
             }
         }
     }
+    
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("getSelectedView()", getSelectedView());
+        dp.writeEntry("isFastScrollEnabled()", isFastScrollEnabled());
+        dp.writeEntry("isScrollingCacheEnabled()", isScrollingCacheEnabled());
+        dp.writeEntry("isSmoothScrollbarEnabled()", isSmoothScrollbarEnabled());
+        dp.writeEntry("isStackFromBottom()", isStackFromBottom());
+        dp.writeEntry("isTextFilterEnabled()", isTextFilterEnabled());
+        super.dumpClass(dp);
+     }
 }
diff --git a/core/java/android/widget/AdapterView.java b/core/java/android/widget/AdapterView.java
index 8fcc2e8..b49dde5 100644
--- a/core/java/android/widget/AdapterView.java
+++ b/core/java/android/widget/AdapterView.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.widget;
 
@@ -1138,4 +1153,12 @@ public abstract class AdapterView<T extends Adapter> extends ViewGroup {
             }
         }
     }
+
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("mFirstPosition", mFirstPosition);
+        dp.writeEntry("mItemCount", mItemCount);
+        dp.writeEntry("mNextSelectedPosition", mNextSelectedPosition);
+        dp.writeEntry("mSelectedPosition", mSelectedPosition);
+        super.dumpClass(dp);
+    }
 }
diff --git a/core/java/android/widget/CheckedTextView.java b/core/java/android/widget/CheckedTextView.java
index bf63607..a1e9cbd 100644
--- a/core/java/android/widget/CheckedTextView.java
+++ b/core/java/android/widget/CheckedTextView.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.widget;
 
@@ -35,6 +50,7 @@ import android.view.accessibility.AccessibilityEvent;
  * something other than {@link android.widget.ListView#CHOICE_MODE_NONE CHOICE_MODE_NONE}.
  *
  */
+
 public class CheckedTextView extends TextView implements Checkable {
     private boolean mChecked;
     private int mCheckMarkResource;
@@ -206,4 +222,9 @@ public class CheckedTextView extends TextView implements Checkable {
         }
         return populated;
     }
+
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("isChecked()", isChecked());
+        super.dumpClass(dp);
+    }
 }
diff --git a/core/java/android/widget/CompoundButton.java b/core/java/android/widget/CompoundButton.java
index bf02ad3..4e0ef47 100644
--- a/core/java/android/widget/CompoundButton.java
+++ b/core/java/android/widget/CompoundButton.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.widget;
 
@@ -342,4 +357,9 @@ public abstract class CompoundButton extends Button implements Checkable {
         setChecked(ss.checked);
         requestLayout();
     }
+    
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("isChecked()", isChecked());
+        super.dumpClass(dp);
+    }
 }
diff --git a/core/java/android/widget/ProgressBar.java b/core/java/android/widget/ProgressBar.java
index ec7d927..250d15a 100644
--- a/core/java/android/widget/ProgressBar.java
+++ b/core/java/android/widget/ProgressBar.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.widget;
 
@@ -949,6 +964,13 @@ public class ProgressBar extends View {
         setProgress(ss.progress);
         setSecondaryProgress(ss.secondaryProgress);
     }
+    
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("getProgress()", getProgress());
+        dp.writeEntry("getSecondaryProgress()", getSecondaryProgress());
+        dp.writeEntry("getMax()", getMax());
+        super.dumpClass(dp);
+    }
 
     @Override
     protected void onAttachedToWindow() {
diff --git a/core/java/android/widget/TableRow.java b/core/java/android/widget/TableRow.java
index b612004..a454b07 100644
--- a/core/java/android/widget/TableRow.java
+++ b/core/java/android/widget/TableRow.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.widget;
 
@@ -500,6 +515,12 @@ public class TableRow extends LinearLayout {
                 height = WRAP_CONTENT;
             }
         }
+        
+        protected void dumpClass(ViewDebug.DumpControl dp) {
+            dp.writeEntry("layout_column", column);
+            dp.writeEntry("layout_span", span);
+            super.dumpClass(dp);
+        }
     }
 
     // special transparent hierarchy change listener
diff --git a/core/java/android/widget/TextView.java b/core/java/android/widget/TextView.java
index 572bd8c..941f904 100644
--- a/core/java/android/widget/TextView.java
+++ b/core/java/android/widget/TextView.java
@@ -13,6 +13,21 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package android.widget;
 
@@ -8384,6 +8399,13 @@ public class TextView extends View implements ViewTreeObserver.OnPreDrawListener
         return mInBatchEditControllers;
     }
 
+    protected void dumpClass(ViewDebug.DumpControl dp) {
+        dp.writeEntry("mText", mText);
+        dp.writeEntry("getSelectionStart()", getSelectionStart());
+        dp.writeEntry("getSelectionEnd()", getSelectionEnd());
+        super.dumpClass(dp);
+    }
+
     @ViewDebug.ExportedProperty
     private CharSequence            mText;
     private CharSequence            mTransformed;
diff --git a/services/java/com/android/server/ViewServer.java b/services/java/com/android/server/ViewServer.java
index 7b5d18a..cb95535 100644
--- a/services/java/com/android/server/ViewServer.java
+++ b/services/java/com/android/server/ViewServer.java
@@ -13,9 +13,25 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+/*
+ * Copyright (C) 2011 Wind River Systems, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package com.android.server;
 
+import android.os.ParcelFileDescriptor;
 import android.util.Slog;
 
 import java.net.ServerSocket;
@@ -190,7 +206,46 @@ class ViewServer implements Runnable {
             }
         }
     }
+    
+    private boolean windowCommandWithDone(Socket client, String command, String parameters)
+    {
+        boolean result;
+        long cmdStartMillis = System.currentTimeMillis();
+
+        result = mWindowManager.viewServerWindowCommand(client, command, parameters);
+
+        long cmdDuration = System.currentTimeMillis() - cmdStartMillis;
+        if(client.getChannel() != null && client.getChannel().isOpen()) {
+	        try {
+	        	// If viewServerWindowCommand() worked then this code
+	        	// doesn't accomplish anything because the client has already
+	        	// seen a DONE and isn't listening.  If something went wrong
+	        	// (e.g., the window Id in the command is not valid), this
+	        	// code will write the only DONE line the client will receive.
+                ParcelFileDescriptor out = ParcelFileDescriptor.fromSocket(client);
+                OutputStream clientStream = new ParcelFileDescriptor.AutoCloseOutputStream(out);
+                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(clientStream), 64);
+
+                bw.write("DONE.");
+                bw.newLine();
+                bw.write("workaround. ");
+                if(result) {
+                        bw.write('t');
+                } else {
+                        bw.write('f');
+                }
+                bw.newLine();
+                bw.flush();
+                bw.close();
+	        } catch (Exception ex) {
+	            Slog.e(LOG_TAG, "failed writing cleanup output stream", ex);
+	        }
+        }
+        Slog.d(LOG_TAG, command + "-done " + Long.toString(cmdDuration));
 
+        return result;
+    }
+    
     private static boolean writeValue(Socket client, String value) {
         boolean result;
         BufferedWriter out = null;
@@ -253,12 +308,14 @@ class ViewServer implements Runnable {
                 } else if (COMMAND_WINDOW_MANAGER_LIST.equalsIgnoreCase(command)) {
                     result = mWindowManager.viewServerListWindows(mClient);
                 } else if (COMMAND_WINDOW_MANAGER_GET_FOCUS.equalsIgnoreCase(command)) {
+                	Slog.d(LOG_TAG, "GET_FOCUS. localPort: " + mClient.getLocalPort() + "  targetPort: " + mClient.getPort());
                     result = mWindowManager.viewServerGetFocusedWindow(mClient);
                 } else if(COMMAND_WINDOW_MANAGER_AUTOLIST.equalsIgnoreCase(command)) {
+                	Slog.d(LOG_TAG, "AUTOLIST. localPort: " + mClient.getLocalPort() + "  targetPort: " + mClient.getPort());
                     result = windowManagerAutolistLoop();
                 } else {
-                    result = mWindowManager.viewServerWindowCommand(mClient,
-                            command, parameters);
+                    Slog.d(LOG_TAG, request + " -- localPort: " + mClient.getLocalPort() + ", targetPort: " + mClient.getPort());
+                    result = windowCommandWithDone(mClient, command, parameters);
                 }
 
                 if (!result) {

